// Copyright 2024-2025 CardinalHQ, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This tool generates the GetBaseObject() method for the PackagedObject message.
// Usage: go run gen_baseobject_getter.go -o output_filename.go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/cardinalhq/oteltools/pkg/graph/graphpb"
)

// caseData holds the information for one oneof case.
type caseData struct {
	// CaseType is the Go type for the oneof wrapper, e.g. "*PackagedObject_PodSummary"
	CaseType string
	// FieldSelector is the field name inside the wrapper that holds the inner message,
	// e.g. "PodSummary"
	FieldSelector string
}

// templateData holds the data passed to the generation template.
type templateData struct {
	PackageName string
	Cases       []caseData
}

func main() {
	// Define and parse the -o flag.
	output := flag.String("o", "", "output file to write the generated source code (required)")
	flag.Parse()

	if *output == "" {
		fmt.Fprintln(os.Stderr, "Error: -o option is required")
		flag.Usage()
		os.Exit(1)
	}

	// Create a temporary PackagedObject instance so we can inspect its descriptor.
	var po graphpb.PackagedObject
	md := po.ProtoReflect().Descriptor()

	// Find the oneof named "object".
	oneof := md.Oneofs().ByName("object")
	if oneof == nil {
		fmt.Fprintln(os.Stderr, "oneof 'object' not found in PackagedObject descriptor")
		os.Exit(1)
	}

	// Build case data for each field (oneof case).
	var cases []caseData
	for i := 0; i < oneof.Fields().Len(); i++ {
		fd := oneof.Fields().Get(i)
		// Assume the proto field name (e.g. "pod_summary") converts to CamelCase (e.g. "PodSummary").
		innerFieldName := snakeToCamel(string(fd.Name()))
		// The generated wrapper type is typically named "PackagedObject_<CamelCaseFieldName>".
		wrapperTypeName := fmt.Sprintf("PackagedObject_%s", innerFieldName)
		caseType := "*" + wrapperTypeName

		cases = append(cases, caseData{
			CaseType:      caseType,
			FieldSelector: innerFieldName,
		})
	}

	// Prepare the data for the template.
	data := templateData{
		PackageName: "graphpb",
		Cases:       cases,
	}

	// Define the template.
	const codeTemplate = `// Copyright 2024-2025 CardinalHQ, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by tools/gen_baseobject_getter.go; DO NOT EDIT.

package {{.PackageName}}

func (po *PackagedObject) GetBaseObject() *BaseObject {
	switch x := po.Object.(type) {
	{{- range .Cases }}
	case {{.CaseType}}:
		return x.{{.FieldSelector}}.BaseObject
	{{- end }}
	default:
		return nil
	}
}

func NewPackagedObject(obj any, rla map[string]string, la map[string]string) *PackagedObject {
	result := &PackagedObject{
		ResourceAttributes: rla,
		RecordAttributes:   la,
	}

	switch s := obj.(type) {
	case *PodSummary:
		result.Object = &PackagedObject_PodSummary{PodSummary: s}
	case *SecretSummary:
		result.Object = &PackagedObject_SecretSummary{SecretSummary: s}
	case *ConfigMapSummary:
		result.Object = &PackagedObject_ConfigMapSummary{ConfigMapSummary: s}
	case *AppsDaemonSetSummary:
		result.Object = &PackagedObject_AppsDaemonSetSummary{AppsDaemonSetSummary: s}
	case *AppsDeploymentSummary:
		result.Object = &PackagedObject_AppsDeploymentSummary{AppsDeploymentSummary: s}
	case *AppsReplicaSetSummary:
		result.Object = &PackagedObject_AppsReplicaSetSummary{AppsReplicaSetSummary: s}
	case *AppsStatefulSetSummary:
		result.Object = &PackagedObject_AppsStatefulSetSummary{AppsStatefulSetSummary: s}
	}
	return nil
}
`
	tmpl := template.Must(template.New("getbaseobject").Parse(codeTemplate))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "template execution error: %v\n", err)
		os.Exit(1)
	}

	// Write the generated source to the specified file.
	if err := os.WriteFile(*output, buf.Bytes(), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "error writing %s: %v\n", *output, err)
		os.Exit(1)
	}
}

// snakeToCamel converts a snake_case string to CamelCase.
func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}
